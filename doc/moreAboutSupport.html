<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">
  <title>Freediag - Vehicle Diagnostic Suite</title>
  <link href="style.css" type="text/css" rel="stylesheet">
</head>

<body>

  <div class="title">FREEDIAG</div>

  <div class="subtitle">More about Supported Interfaces.</div>

  <br><br>

  <div align="center">
    <img src="title.png">
    <br>
    [ <a href="http://www.sourceforge.net/projects/freediag/"> Freediag@Sourcefo
rge </a> ]
    [ <a href="index.html"> Home </a> ]
    [ <a href="Scantool-Manual.html"> Documentation </a> ]
    <br>

    [ <a href="http://sourceforge.net/mail/?group_id=34714"> Mailing Lists </a>
]
    [ <a href="http://sourceforge.net/p/freediag/code/"> CVS Access </a> ]
  </div>

  <br>


Vasco Nevoa wrote:
<p>
To clarify once and for all - in freediag:
<p>
Supported PC<->Car Interfaces (comments taken from the source,
my opinion remarked with "vnevoa"):

<H2>-- diag_l0_br.c:</H2>
<ul>
    <li> B. Roadman BR-1 Interface
    <li> Semi intelligent interface, supports only J1979 properly, and does not
         support ISO14230 (KWP2000). In ISO9141-2 mode, only supports the
         ISO9141-2 address (0x33h)
</ul>
    vnevoa: I don't know this one, but looks like it's related to
    ALDL.  This is an active interface (implemented with
    a PIC microcontroller) which simplifies life A LOT for the SW
    programmers... too easy for us!.. ;)  we like the complication of
    timing issues in our SW! :))

<H2>-- diag_l0_elm.c:</H2>
<ul>
   <li> Incomplete, work in progress. This will support ELMxxx devices and hopefully clones as well. These are PIC-based
   and are considered "smart".
</ul>

<H2>-- diag_l0_me.c:</H2>
<ul>
    <li> Interface for Multiplex Engineering interface.
    <li> Supports #T16 interface only. Other interfaces need special
         code to read multi-frame messages with > 3 frames (and don't
         support all interface types).
</ul>
   vnevoa: never heard of it. From their web page I can see that it is
   also an Active interface, but it looks like they are using something
   better than a PIC, which will probably result in a higher-quality,
   more-featured protocol.

<H2>-- diag_l0_dumb.c: </H2>
<ul>
    <li> interface for generic "dumb" interfaces, such as VAGTool &
 clones, Jeff Noxon's opendiag interface, and all simple converters without
  an onboard microcontroller.
    <li> This is also tested with the Silicon Engines K line only interface.
</ul>
   vnevoa: This is my baby :)...  This  supports any Passive interface,
   that is, this file does not really deal with any dreamed-up protocol,
   it deals directly with the car's protocol, just like it was defined
   by ISO(international) and SAE(USA). The fact that VAGtool is(was)
   the most well-known comercial name around at the time, and that
   VAG is for VolksWagen too, gave it the name we are using (vw) - but
   this is an unfortunate name, as you can see. This file is the one we
   REALLY need to be carefull and pay attention to timing issues... it
   involves kernel tweaks and everything... so this is the difficult
   one to port between OSs...  My personal interface is a very cheap
   "Andy-Whittaker", and it can do any protocol (all OBD2 flavours,
   plus ALDL!)... provided the PC SW knows what it's doing!!! ;)
</pre>

<H2>-- diag_l0_sim.c:</H2>
<ul>
   <li> the CARSIM interface allows testing of higher levels (L2, L3) without
   having an actual car connected. It reads requests and responses from a file.
</ul><p>This was coded by vnevoa ~2004. From his presentation: <br>
Basically, it is a file reader and parser that searches for the byte
sequence that is being sent to the car, and if it finds any number of
answers for it, it simulates the responses from the car. I included a
simple parsing mechanism to simulate whatever test values we want by
placing a few text tokens inside the response sequences, which get
translated into byte values through specific functions.</br>
<p>
<h3>Summary</h3>
So, when it comes to interfaces (IFCs), we can conclude there are two general 
classes of interfaces, which we refer to as "active" / "smart" (with
a microcontroller unit - mcu) and "passive" / "dumb" (no mcu, only signal
level translation and optionally opto-isolation).
<p>
<ol>

<li> "Active" IFCs are very friendly for the programmers, because
they take care of all the car protocol timing issues, and turn the
very strange and demanding signals into a simple PC serial port flow
of characters. This is like using the "AT"modem commands, so you can
see how easy it is. So timing is not critical and can be left to the
interface HW, and logical results are garanteed at the SW level. However,
the protocol is interface-proprietary.
<p>

<li> "Passive" IFCs have very little electronics on them, because they
only try to protect the PC serial port and adapt the voltage levels (with
optical isolation) . This means that the PC is dealing directly with the
car's ECU signals, and therefore the timing must be VERY precise. But
these IFCs have one BIG advantage: they are Open-Source and Future
friendly!!! What I mean is that we can implement any kind of logical
protocol we want with them, because they are protocol-ignorant! If
you try using an Active IFC on a car with a protocol that it doesn't
"speak", you are dependent upon the IFC manufacturer to update the IFC's
firmware...  This is why I prefer Passive IFCs.... the future protocol
implementations depend only upon us! Same with the car's brand-specific
protocol extensions. Neat.
</ol>
<p>
</body>
</html>

