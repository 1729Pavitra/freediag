***
fenugrec - 2014
This is bits and pieces of descriptions of elements of the source code. The
code can be confusing, and it takes time to become familiar with all the
data structures, functions, etc. In the ~15 years' existence of the project,
I think no one took the trouble of documenting the source code beyond 
comments directly in the source. This is OK but I felt there was a need for
a short document that would explain some concepts more in detail, a sort
of quick-reference guide for understanding / hacking freediag.
At the moment this is just a collection of notes : whenever I spend
more than a few minutes investigating something in the code, I write
a brief summary in here. Hopefully this will benefit someone else
as well.
***
Physical interfaces (i.e. ELM323, dumb adaptor, etc) are connected to a serial port (usually called
"subinterface" in the code). Only one L0 driver can use a given "subinterface", ex.: /dev/ttyUSB0
is owned exclusively diag_l0_elm, etc.
This association is a "struct diag_l0_device", often "dl0d" in the code.

struct diag_l0_device : as of 1.01, this contains general and OS-specific fields, and is defined
in the relevant diag_tty_???.h header. diag_tty_open allocs and fills a diag_l0_device
structure when called; this associates a given l0 driver and the specified subinterface.
diag_tty_close closes and free's the specified diag_l0_device.
Typically a diag_l0_device structure is created an filled when diag_l1_open is called (see below)
It also points to the diag_l2_link that "owns" it.

struct diag_l0 : every diag_l0_???.c driver fills in one of these to describe itself. It includes
its name; supported L1 protos, and pointers to "exposed" functions (diag_l0_initbus, _setspeed, etc)
Those diag_l0 structs are added to the linked list l0dev_list by diag_l0_config.

struct diag_l2_proto : every diag_l2_???.c handler fills in one of these to describe itself. 

struct diag_l2_link : these are alloc'ed + filled by diag_l2_open; diag_l2_links is a linked-list
 of all the active l2 links. An l2 link associates a diag_l0_device with one L1 protocol. This
 struct also holds flags (inits supported, etc.). The member "char diag_l2_name[]" is
 currently filled with the name of the l0 driver ("DUMB", "ELM", etc.)! This means
 we can't use two separate physical l0 devices of the same type (ex.: two ELM323 cables) !
 This is not a problem for now since many l0 drivers wouldn't support it (some have global
 flags not part of their diag_l0_device struct)
 Note : despite the name, diag_l2_link says nothing about the L2 protocol used.
 See struct diag_l2_conn/

diag_l2_close : this is called from cmd_diag_disconnect to close the global_l2_dl0d XXX

diag_l1_close calls the ->diag_l0_close func of the specified diag_l0_device; this terminates
 an existing link between an l0 driver and its serial port. Only called in diag_l2_closelink;
diag_l2_closelink is called by diag_l2_open only ? so nothing ever closes the l0 devices !

diag_l2_open: calls diag_l1_open with specified l0name, subinterface, l1proto;
 adds a diag_l2_link to the diag_l2_links linked-list if successful. For some reason
 this returns struct diag_l0_device .

diag_l1_open: finds l0name in the linked list l0dev_list; calls the l0 driver's diag_l0_open
 function with the specified subinterface and L1 proto.  Returns the struct diag_l0_device *
 it got from ->diag_l0_open.
diag_l1_open is currently only called from diag_l2_open.

->diag_l0_open(...) : this function, defined by each l0 driver, alloc's + fills a new diag_l0_device struct.
 


diag_l0_initbus : these are called by diag_l1_initibus; diag_l1_initbus is only called by
 diag_l2_ioctl.
diag_l0_initbus is assumed to return at exactly :
- the end of tWUP, if iso14230 fastinit (just in time to send the startcomm request)
- right after receiving the 0x55 sync byte, if iso9141 or iso14230 slowinit (just in time to get the 2x keybytes)


diag_tty_write : diag_l0_dumb, in certain cases, would need this to be non-blocking... I'm unsure of how
the different implementations handle this.


cmd_diag_addl3 : this supposes we already have a global L2 connection to an ECU; it
 defines global_l3_conn if diag_l3_start() is succesful

**** layer "tree"
As of 1.01, here's roughly how the layers can be interconnected :

"subinterface" : a physical serial port. The code calls this a subinterface for some unknown reason;
 I think it was an abstraction for something that is now absent in the code...

L0 :
any "subinterface" can be associated with only one l0 driver. This link is defined in
a struct diag_l0_device described earlier;
Most L0 drivers don't support multiple "instances" of themselves (i.e. trying to use an ELM on ttyS0
and another ELM on ttyS1 at the same time); this is partly due to global variables in each l0 driver.
Also, no precautions have been taken to make the l0 drivers re-entrant (see async-safeness note
later in this doc), so attempting this could be dangerous !

L1 : this is mostly a "glue" layer: the differences bewteen L1 protocols (DIAG_L1_* in diag_l1.h) are
handled in the l0 drivers. The code in diag_l1.c interprets the L1flags and acts accordingly; this
makes it mostly pass-through except for diag_l1_send which takes care of P4 timing and half-duplex
removal.
There are no specific data structures linking the L1 and L0 levels.

L2 : As I understand, this layer tries to abstract much of the differences between standards.

L3 : there's also a linked-list for l3 connections : diag_l3_list; 



**** "async signal safe"ness, re-entrant functions, callbacks etc.
This is currently (2014) a bit of a mess. The previous devs knew this was the
next big problem to tackle, so they flagged many parts of the code as non-async signal
safe AKA "not re-entrant". These functions (and others) should be made re-entrant, i.e.
take the necessary precautions so that, if a thread is currently executing
the function, another thread can safely call the same function.
Luckily we don't create many threads in freediag. I think the only case where
this can happen is with the periodic timer functions (diag_l2_timer and diag_l3_timer)
which theoretically get called by the OS automatically at a preset interval, presumably
to transmit keep-alive messages.
All of this is very much a work in progress.