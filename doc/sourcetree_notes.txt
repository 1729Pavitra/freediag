physical interfaces (i.e. ELM323, dumb adaptor, etc) are connected to a serial port; usually called
"subinterface" in the code. Only one L0 driver can use a given "subinterface"; i.e. /dev/ttyUSB0
owned by diag_l0_elm. This association is a "struct diag_l0_device", often "dl0d" in the code.

struct diag_l0_device : as of 1.01, this contains general and OS-specific fields, and is defined
in the relevant diag_tty_???.h header. The members ".name" and ".ttystate" are alloc'ed
and free'd in diag_tty;

struct diag_l0 : every diag_l0_???.c driver fills in one of these to describe itself. It includes
its name; supported L1 protos, and pointers to "exposed" functions (diag_l0_initbus, _setspeed, etc)
Those diag_l0 structs are added to the linked list l0dev_list by diag_l0_config.


l0 devices are closed by diag_l1_close;
diag_l1_close is only called in diag_l2_closelink;
diag_l2_closelink is called by diag_l2_open only ? so nothing ever closes the l0 devices !

diag_l2_open calls diag_l1_open


diag_l0_initbus : these are called by diag_l1_initibus; diag_l1_initbus is called by
diag_l2_ioctl with the right IOCTL.
diag_l0_initbus is assumed to return at exactly :
- the end of tWUP, if iso14230 fastinit (just in time to send the startcomm request)
- right after receiving the 0x55 sync byte, if iso9141 or iso14230 slowinit (just in time to get the 2x keybytes)


diag_tty_write : diag_l0_dumb, in certain cases, would need this to be non-blocking... I'm unsure of how
the different implementations handle this.